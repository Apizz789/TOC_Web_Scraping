{"ast":null,"code":"export default function TrieNode(letter) {\n  // properties \n  this.letter = letter;\n  this.prevLetter = null;\n  this.nextLetters = {}; // an object for the following letters\n\n  this.isComplete = false; // check whether letter is last of word\n  //methods\n\n  this.getWord = getWord; // iterates through nodes to get word prediction\n\n  function getWord() {\n    var node = this;\n    var wordLetters = [];\n\n    while (node.prevLetter) {\n      wordLetters.unshift(node.letter);\n      node = node.prevLetter; // set the previous letter as node\n    }\n\n    return wordLetters.join(\"\");\n  }\n\n  ;\n}\n_c = TrieNode;\n\nfunction Trie() {\n  // properties\n  this.root = new TrieNode(null); // methods\n\n  this.insert = insert; // insert new word in trie\n\n  this.contains = contains; // check if word exists\n\n  this.find = find; // find words similar with previous letters\n  // insert new word in Trie\n\n  function insert(word) {\n    var node = this.root; // set first node to root node\n\n    for (let i = 0; i < word.length; i++) {\n      const current_letter = word[i];\n\n      if (!node.nextLetters[current_letter]) {\n        // if letter not in next letters\n        node.nextLetters[current_letter] = new TrieNode(current_letter); // make it node\n\n        node.nextLetters[current_letter].prevLetter = node; // add it as a child node\n      }\n\n      node = node.nextLetters[current_letter]; // reset node to current letter & continue iteration\n      // check whether whole word is inserted\n\n      if (i === word.length - 1) {\n        node.isComplete = true;\n      }\n    }\n  }\n\n  ; // check if word exists\n\n  function contains(word) {\n    var node = this.root; // set first node to root node\n\n    for (let i = 0; i < word.length; i++) {\n      const current_letter = word[i];\n      let next_node = node.nextLetters[current_letter];\n\n      if (next_node) {\n        // if letter is one of next letters\n        node = next_node; // set it as a next node\n      } else {\n        return false;\n      }\n    }\n\n    return node.isComplete; // definitely returns 'true'\n  }\n\n  ; // find words with similar previous letters\n\n  function find(clue_letters) {\n    var node = this.root; // set first node to root node\n\n    var output = [];\n\n    for (let i = 0; i < clue_letters.length; i++) {\n      const clue_letter = clue_letters[i];\n      let next_node = node.nextLetters[clue_letter];\n\n      if (next_node) {\n        // if clue letter is one of next letters\n        node = next_node; // set it as next node\n      } else {\n        return output;\n      }\n    } // use the last node to find the next possible words\n\n\n    findAllWords(node, output);\n    return output;\n  }\n\n  ; // function that finds next possible words\n\n  function findAllWords(node, arr) {\n    if (node.isComplete) {\n      // check if node is end node\n      arr.unshift(node.getWord()); // get all words and add them to array\n    } // otherwise recursively call the next nodes\n\n\n    for (var next_letter in node.nextLetters) {\n      findAllWords(node.nextLetters[next_letter], arr);\n    }\n  }\n} // var fs = require('fs');\n// var text = fs.readFileSync(\"./sample.txt\", 'utf-8');\n// var words = text.replace(/[.,\\/#!$%^&\\^&\\*;:{}=\\-_`~()?]/g,\"\").replace(/(\\r\\n|\\n|\\r)/gm, ' ').split(' ')\n// var myTrie = new Trie();\n// for (let i = 0; i < words.length; i++) {\n//     const word = words[i];\n//     myTrie.insert(word)\n//     console.log(word)\n// }\n//console.log(myTrie.find('te'))\n\n\n_c2 = Trie;\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"TrieNode\");\n$RefreshReg$(_c2, \"Trie\");","map":{"version":3,"sources":["C:/Users/MrZOMBIT/Desktop/2021/Works/CE3D/Software Studio/TOC_Web_Scraping/web_scraping/src/components/trie.js"],"names":["TrieNode","letter","prevLetter","nextLetters","isComplete","getWord","node","wordLetters","unshift","join","Trie","root","insert","contains","find","word","i","length","current_letter","next_node","clue_letters","output","clue_letter","findAllWords","arr","next_letter"],"mappings":"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","sourcesContent":["export default function TrieNode(letter) {\r\n    // properties \r\n    this.letter = letter;\r\n    this.prevLetter = null;\r\n    this.nextLetters = {}; // an object for the following letters\r\n    this.isComplete = false; // check whether letter is last of word\r\n  \r\n    //methods\r\n    this.getWord = getWord;\r\n  \r\n    // iterates through nodes to get word prediction\r\n    function getWord() {\r\n      var node = this;\r\n      var wordLetters = [];\r\n      while (node.prevLetter) {\r\n        wordLetters.unshift(node.letter);\r\n        node = node.prevLetter; // set the previous letter as node\r\n      }\r\n      return wordLetters.join(\"\");\r\n    };\r\n  }\r\n  \r\n  function Trie() {\r\n    // properties\r\n    this.root = new TrieNode(null);\r\n  \r\n    // methods\r\n    this.insert = insert; // insert new word in trie\r\n    this.contains = contains; // check if word exists\r\n    this.find = find; // find words similar with previous letters\r\n  \r\n    // insert new word in Trie\r\n    function insert(word) {\r\n      var node = this.root; // set first node to root node\r\n      for (let i = 0; i < word.length; i++) {\r\n        const current_letter = word[i];\r\n        if (!node.nextLetters[current_letter]) { // if letter not in next letters\r\n          node.nextLetters[current_letter] = new TrieNode(current_letter); // make it node\r\n          node.nextLetters[current_letter].prevLetter = node; // add it as a child node\r\n        }\r\n        node = node.nextLetters[current_letter]; // reset node to current letter & continue iteration\r\n  \r\n        // check whether whole word is inserted\r\n        if (i === word.length - 1) {\r\n          node.isComplete = true;\r\n        }\r\n      }\r\n    };\r\n  \r\n    // check if word exists\r\n    function contains(word) {\r\n      var node = this.root; // set first node to root node\r\n      for (let i = 0; i < word.length; i++) {\r\n        const current_letter = word[i];\r\n        let next_node = node.nextLetters[current_letter];\r\n        if (next_node) { // if letter is one of next letters\r\n          node = next_node; // set it as a next node\r\n        } else {\r\n          return false;\r\n        }\r\n      }\r\n      return node.isComplete; // definitely returns 'true'\r\n    };\r\n  \r\n    // find words with similar previous letters\r\n    function find(clue_letters) {\r\n      var node = this.root; // set first node to root node\r\n      var output = [];\r\n      for (let i = 0; i < clue_letters.length; i++) {\r\n        const clue_letter = clue_letters[i];\r\n        let next_node = node.nextLetters[clue_letter];\r\n        if (next_node) { // if clue letter is one of next letters\r\n          node = next_node; // set it as next node\r\n        } else {\r\n          return output;\r\n        }\r\n      }\r\n  \r\n      // use the last node to find the next possible words\r\n      findAllWords(node, output);\r\n      return output;\r\n    };\r\n  \r\n    // function that finds next possible words\r\n    function findAllWords(node, arr) {\r\n      if (node.isComplete) { // check if node is end node\r\n        arr.unshift(node.getWord()); // get all words and add them to array\r\n      }\r\n  \r\n      // otherwise recursively call the next nodes\r\n      for (var next_letter in node.nextLetters) {\r\n        findAllWords(node.nextLetters[next_letter], arr);\r\n      }\r\n    }\r\n  }\r\n  \r\n  \r\n  // var fs = require('fs');\r\n  // var text = fs.readFileSync(\"./sample.txt\", 'utf-8');\r\n  // var words = text.replace(/[.,\\/#!$%^&\\^&\\*;:{}=\\-_`~()?]/g,\"\").replace(/(\\r\\n|\\n|\\r)/gm, ' ').split(' ')\r\n  \r\n  // var myTrie = new Trie();\r\n  // for (let i = 0; i < words.length; i++) {\r\n  //     const word = words[i];\r\n  //     myTrie.insert(word)\r\n  //     console.log(word)\r\n  // }\r\n  \r\n  //console.log(myTrie.find('te'))\r\n  "]},"metadata":{},"sourceType":"module"}